/*
 * i2c.c
 *
 *  Created on: Dec 19, 2025
 *      Author: Admin
 */
#include "mydriver.h"

/* ================== BASE ADDRESS ================== */
#define RCC_BASE_ADDR        0x40023800
#define GPIOA_BASE_ADDR      0x40020000
#define GPIOB_BASE_ADDR      0x40020400
#define GPIOD_BASE_ADDR      0x40020C00
#define I2C1_BASE_ADDR       0x40005400

/* ================== RCC ================== */
#define RCC_AHB1ENR   (*(volatile uint32_t*)(RCC_BASE_ADDR + 0x30))
#define RCC_APB1ENR   (*(volatile uint32_t*)(RCC_BASE_ADDR + 0x40))

/* ================== GPIO ================== */
#define GPIOB_MODER   (*(volatile uint32_t*)(GPIOB_BASE_ADDR + 0x00))
#define GPIOB_OTYPER  (*(volatile uint32_t*)(GPIOB_BASE_ADDR + 0x04))
#define GPIOB_OSPEEDR (*(volatile uint32_t*)(GPIOB_BASE_ADDR + 0x08))
#define GPIOB_PUPDR   (*(volatile uint32_t*)(GPIOB_BASE_ADDR + 0x0C))
#define GPIOB_AFRH    (*(volatile uint32_t*)(GPIOB_BASE_ADDR + 0x24))

/* ================== I2C1 ================== */
#define I2C1_CR1     (*(volatile uint32_t*)(I2C1_BASE_ADDR + 0x00))
#define I2C1_CR2     (*(volatile uint32_t*)(I2C1_BASE_ADDR + 0x04))
#define I2C1_DR      (*(volatile uint32_t*)(I2C1_BASE_ADDR + 0x10))
#define I2C1_SR1     (*(volatile uint32_t*)(I2C1_BASE_ADDR + 0x14))
#define I2C1_SR2     (*(volatile uint32_t*)(I2C1_BASE_ADDR + 0x18))
#define I2C1_CCR     (*(volatile uint32_t*)(I2C1_BASE_ADDR + 0x1C))
#define I2C1_TRISE   (*(volatile uint32_t*)(I2C1_BASE_ADDR + 0x20))


/* ====== I2C1 Master – STM32F401 (PB8=SCL, PB9=SDA) ====== */
void I2C1_Master_Init(void)
{
    /* Enable clock GPIOB + I2C1 */
    volatile uint32_t *RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
    volatile uint32_t *RCC_APB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x40);

    *RCC_AHB1ENR |= (1 << 1);     // GPIOB
    *RCC_APB1ENR |= (1 << 21);    // I2C1

    /* GPIOB config */
    volatile uint32_t *MODER   = (uint32_t*)(GPIOB_BASE_ADDR + 0x00);
    volatile uint32_t *OTYPER  = (uint32_t*)(GPIOB_BASE_ADDR + 0x04);
    volatile uint32_t *OSPEEDR = (uint32_t*)(GPIOB_BASE_ADDR + 0x08);
    volatile uint32_t *PUPDR   = (uint32_t*)(GPIOB_BASE_ADDR + 0x0C);
    volatile uint32_t *AFRH    = (uint32_t*)(GPIOB_BASE_ADDR + 0x24);

    /* PB8, PB9 -> AF4 */
    *MODER &= ~((3<<(8*2)) | (3<<(9*2)));
    *MODER |=  ((2<<(8*2)) | (2<<(9*2)));   // Alternate function

    *OTYPER |= (1<<8) | (1<<9);              // Open-drain
    *OSPEEDR |= (3<<(8*2)) | (3<<(9*2));     // High speed

    *PUPDR &= ~((3<<(8*2)) | (3<<(9*2)));
    *PUPDR |=  ((1<<(8*2)) | (1<<(9*2)));    // Pull-up

    *AFRH &= ~((0xF<<((8-8)*4)) | (0xF<<((9-8)*4)));
    *AFRH |=  ((0x4<<((8-8)*4)) | (0x4<<((9-8)*4))); // AF4

    /* I2C registers */
    volatile uint32_t *CR1   = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t *CR2   = (uint32_t*)(I2C1_BASE_ADDR + 0x04);
    volatile uint32_t *CCR   = (uint32_t*)(I2C1_BASE_ADDR + 0x1C);
    volatile uint32_t *TRISE = (uint32_t*)(I2C1_BASE_ADDR + 0x20);

    *CR1 &= ~(1<<0);     // PE = 0
    *CR2 = 16;           // APB1 = 16 MHz
    *CCR = 80;           // 100 kHz standard mode
    *TRISE = 17;         // (1000ns / 62.5ns) + 1
    *CR1 |= (1<<10);     // ACK enable
    *CR1 |= (1<<0);      // PE = 1
}
void I2C1_WriteReg(uint8_t dev, uint8_t reg, uint8_t data)
{
    volatile uint32_t *CR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t *SR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x14);
    volatile uint32_t *SR2 = (uint32_t*)(I2C1_BASE_ADDR + 0x18);
    volatile uint32_t *DR  = (uint32_t*)(I2C1_BASE_ADDR + 0x10);

    *CR1 |= (1<<8);                    // START
    while(!(*SR1 & 1));                // SB

    *DR = dev << 1;                    // Write
    while(!(*SR1 & (1<<1)));           // ADDR
    (void)*SR2;

    while(!(*SR1 & (1<<7)));           // TxE
    *DR = reg;

    while(!(*SR1 & (1<<7)));
    *DR = data;

    while(!(*SR1 & (1<<2)));           // BTF
    *CR1 |= (1<<9);                    // STOP
}
void I2C1_ReadMulti(uint8_t dev, uint8_t reg, uint8_t *buf, uint8_t len)
{
    volatile uint32_t *CR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t *SR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x14);
    volatile uint32_t *SR2 = (uint32_t*)(I2C1_BASE_ADDR + 0x18);
    volatile uint32_t *DR  = (uint32_t*)(I2C1_BASE_ADDR + 0x10);

    /* Write register address */
    *CR1 |= (1<<8);
    while(!(*SR1 & 1));
    *DR = dev << 1;
    while(!(*SR1 & (1<<1)));
    (void)*SR2;

    while(!(*SR1 & (1<<7)));
    *DR = reg;

    while(!(*SR1 & (1<<7)));

    /* Repeated START – Read */
    *CR1 |= (1<<8);
    while(!(*SR1 & 1));
    *DR = (dev << 1) | 1;
    while(!(*SR1 & (1<<1)));
    (void)*SR2;

    for(uint8_t i=0;i<len;i++)
    {
        if(i == len-1)
        {
            *CR1 &= ~(1<<10);  // ACK = 0
            *CR1 |= (1<<9);    // STOP
        }
        while(!(*SR1 & (1<<6))); // RxNE
        buf[i] = *DR;
    }
    *CR1 |= (1<<10); // ACK lại
}

